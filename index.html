<!DOCTYPE HTML>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Colorball</title>
	<style type="text/css">
body {
	margin: 0;
	background-color: #777;
}

#stats-widget {
	position: absolute;
	top: 0px;
}
	</style>
</head>
<body>
	<script type="text/javascript" src="three.js/build/three.min.js"></script>
	<script type="text/javascript" src="libs/stats.min.js"></script>
	<script type="text/javascript" src="three.js/examples/js/controls/TrackballControls.js"></script>
	<script>
		"use strict";

		var faceIndices = ['a', 'b', 'c', 'd'];

		function colorVerticesBySphericalCoordinates(geometry, radius) {
			/*
			Hue = latitude
			Saturation = distance from polar axis, proportional to radius
			Luminance = longitude
			*/
			for(var i = 0; i < geometry.faces.length; i++) {
				var face = geometry.faces[i];
				var vertices = (face instanceof THREE.Face3)? 3: 4;

				for(var v = 0; v < vertices; v++) {
					var vertexIndex = face[faceIndices[v]];
					var vertex = geometry.vertices[vertexIndex];

					var longitude = Math.atan2(vertex.x, vertex.z);
					var latitude = Math.acos(vertex.y / radius);
					var distanceFromCenter = Math.sqrt(Math.pow(vertex.x, 2) + Math.pow(vertex.z, 2));

					var color = new THREE.Color(0xfff000);
					var H = (longitude / Math.PI + 1) / 2;
					var S = distanceFromCenter / radius;
					var L = latitude / Math.PI * -1 + 1;

					color.setHSL(H, S, L);

					face.vertexColors[v] = color;
				}
			}
		}

		function isVertexAbovePlane(vertex, plane) {
			var v = new THREE.Vector3(0, 0, 0);
			vertex = v.copy(vertex); // Because sub() and copy() both modify the object in place.
			var planeToVertex = vertex.sub(plane.center).normalize();
			var angle = plane.normal.dot(planeToVertex);

			if(angle / Math.PI >= 0) return true;
			else return false;
		}

		function bisectAlongPlane(geometry, plane) {
			/*
			geometry: A THREE.Geometry that will be cut.
			plane: {
				center: THREE.Vector3
				normal: THREE.Vector3
			}
			The coordinates of the plane must be in the same space as geometry.vertices.
			*/

			var upperVertices = []; // I wish this was a set.

			for(var i = 0; i < geometry.vertices.length; i++) {
				var vertex = geometry.vertices[i];
				if(isVertexAbovePlane(vertex, plane))
					upperVertices.push(vertex);
			}

			var remainingFaces = [];
			var intersectingEdges = [];
			for(var i = 0; i < geometry.faces.length; i++) {
				var face = geometry.faces[i];
				var verticesPerFace = (face instanceof THREE.Face3)? 3: 4;
				var isFaceAbovePlane = true;

				// Two birds with one stone: Find faces to remove and find edges that intersect the plane.
				var lastVertex;
				var isLastVertexAbovePlane;
				for(var j = 0; j < verticesPerFace; j++) {
					var vertex = geometry.vertices[face[faceIndices[j]]];
					if(isVertexAbovePlane(vertex, plane)) {
						isLastVertexAbovePlane = true;
					} else {
						if(isLastVertexAbovePlane)
							intersectingEdges.push([lastVertex, vertex]);
						isLastVertexAbovePlane = false;
						isFaceAbovePlane = false;
					}
					lastVertex = vertex;
				}

				if(!isFaceAbovePlane)
					remainingFaces.push(face);
			}
			geometry.faces = remainingFaces;

			// Move points that are on the wrong side of the plane to the intersection of the sphere and the plane, moving through a plane described by a point, the vertex, and by a line, the normal of the intersecting plane.
			intersectingEdges.forEach(function(edge) {
				var stationaryPoint, moveablePoint;
				if(isVertexAbovePlane(edge[0], plane)) {
					moveablePoint = edge[0];
					stationaryPoint = edge[1];
				} else {
					moveablePoint = edge[1];
					stationaryPoint = edge[0];
				}
			});

			geometry.dynamic = true;
			geometry.verticesNeedUpdate = true;
		}

		(function() {
			var camera, scene, renderer, controls;
			var mesh;
			var stats;

			function init() {

				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.z = 1000;

				scene = new THREE.Scene();

				var plane = new THREE.Plane
				var planeGeometry = new THREE.PlaneGeometry(800, 800, 2, 2);
				var planeMesh = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({
					color: 0xffff00,
					wireframe: true,
					transparent: true,
					opacity: .25
				}));

				scene.add(planeMesh);

				var radius = 300;
				var subdivisions = 100;

				var geometry = new THREE.IcosahedronGeometry(radius, 1);
				colorVerticesBySphericalCoordinates(geometry, radius);
				bisectAlongPlane(geometry, {
					center: new THREE.Vector3(0, 0, 0),
					normal: new THREE.Vector3(0, 0, 1).normalize()
				});

				var materials = [
					new THREE.MeshLambertMaterial({
						shading: THREE.SmoothShading,
						vertexColors: THREE.VertexColors
					}),
					new THREE.MeshBasicMaterial({
						color: 0,
						wireframe: true,
						transparent: true,
						opacity: .1
					})
				];

				mesh = new THREE.SceneUtils.createMultiMaterialObject(geometry, materials);
				scene.add(mesh);

				scene.add(new THREE.AmbientLight(0xffffff));

				renderer = new THREE.WebGLRenderer({
					antialias: true
				});
				renderer.setSize(window.innerWidth, window.innerHeight);

				controls = new THREE.TrackballControls(camera, renderer.domElement);

				document.body.appendChild(renderer.domElement);
				stats = new Stats();
				stats.domElement.id = 'stats-widget';
				document.body.appendChild(stats.domElement);

			}

			function animate() {

				// note: three.js includes requestAnimationFrame shim
				requestAnimationFrame(animate);

				controls.update();
				renderer.render(scene, camera);
				stats.update();

			}

			init();
			animate();
		})();
	</script>
</body>
</html>
